---
title: "排序"
date: 2025-12-27
summary: "记一些排序算法"
published: false
---

## 排序

### 快速排序
#### 流程
1.选择一个`pivot`
2.根据`pivot`将数组分为左右两部分
3.以递归的方式，对左右两部分重复上述过程
#### 时间复杂度
1. 最好情况: $O(nlogn)$。每一次都能均分左右两边
2. 最差情况: $O(n^2)$。已经拍好序的数组，每次都是左边一个元素，右边是n-1个元素
3. 平均情况: $O(nlogn)$
粗略计算：
``` 
Level 0:      n
Level 1:    n/2  n/2
Level 2:  n/4 n/4 n/4 n/4
```
总共分成$log(n)$层，每一层都是n个元素的遍历，时间复杂度为$nlog(n)$

#### 实现1
最普通的实现，每次选择最左侧元素作为pivot
``` c++
void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;

    int pivotIndex = left + rand() % (right - left + 1);
    swap(nums[left], nums[pivotIndex]);

    int pivot = nums[left];
    int l = left;

    for (int i = left + 1; i <= right; i++) {
        if (nums[i] < pivot) {
            l++;
            swap(nums[l], nums[i]);
        }
    }

    swap(nums[left], nums[l]);

    quickSort(nums, left, l - 1);
    quickSort(nums, l + 1, right);
}
```

#### 实现2: Dutch National Flag（DNF）三路快排

针对数组中可能存在大量重复元素，使用三路划分法优化：

``` c++
void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;

    // 随机选择 pivot，避免最坏情况 O(n^2)
    int pivotIndex = left + rand() % (right - left + 1);
    swap(nums[left], nums[pivotIndex]);

    int pivot = nums[left];
    int lt = left;      // < pivot 的右边界
    int i  = left + 1;  // 当前处理元素
    int gt = right;     // > pivot 的左边界

    // 遍历未处理区间
    while (i <= gt) {
        if (nums[i] < pivot) {
            swap(nums[i], nums[lt]);
            i++;
            lt++;
        } else if (nums[i] > pivot) {
            swap(nums[i], nums[gt]);
            gt--;
            // i 不加，因为换过来的元素还没处理
        } else {
            i++;
        }
    }

    // 递归处理左右两边，中间区 == pivot 已经排好
    quickSort(nums, left, lt - 1);
    quickSort(nums, gt + 1, right);
}
``` 

**核心逻辑**
利用区间不变式：
+ [left, lt-1] < pivot
+ [lt, i-1] == pivot
+ [i, gt] 未处理
+ [gt+1, right] > pivot

每次循环根据元素大小更新区间，保证已处理区间始终正确
递归只处理 < pivot 和 > pivot 两边，避免重复处理 == pivot 区
随机 pivot 保证平均时间复杂度稳定在 $O(n \log n)$

leetcode：75 颜色分类，将数组中的0，1，2按序排列可以直接使用这种三指针的方式，进行排列，区间不变式稍微有点变化：
+ (left, lt] == 0
+ (lt, i) == 1
+ [i, rt] 未处理
+ (rt, right] == 2

``` C++
  void sortColors(vector<int> &nums) {
    int lt = -1;
    int i = 0;
    int rt = nums.size() - 1;
    while (i <= rt) {
      if (nums[i] == 0) {
        swap(nums[++lt], nums[i++]);
      } else if (nums[i] == 2) {
        swap(nums[i], nums[rt--]);
      } else {
        i++;
      }
    }
  }
```