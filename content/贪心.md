---
title: "贪心"
date: 2025-12-31
summary: "Summary of your new post."
published: false
---

本文目标是**建立稳定的贪心刷题认知框架，避免重复刷题**，并通过一段极具代表性的代码（LeetCode 881 救生艇）来加深对贪心思想的理解。

---

## 一、什么是贪心算法（面向刷题的定义）

> 贪心算法：在每一步选择中，都做出**当前看起来最优**的决策，并且该决策**不会影响最终全局最优解**。

刷题中，贪心是否成立，取决于两点：

1. **贪心选择性质**：当前的局部最优选择可以直接进入某个最优解
2. **最优子结构**：问题在做出一次选择后，剩余部分仍是同类型的最优问题

---

## 二、贪心题目的本质分类（避免重复刷题）

下面的分类是按**决策本质**划分，而不是题目表象。同一类题目，思路高度一致，只需刷 1–2 道即可。

---

## 1️⃣ 资源–需求匹配型（Matching Greedy）

### 核心问题

> 用有限资源，满足尽可能多的需求

### 统一贪心策略

* 对资源和需求排序
* **最小资源 → 最小需求**（或最大对最大）
* 保留“适配能力强”的资源给后面

### 典型证明

* 交换论证：如果最优解没有这么配，可以交换而不变差

### 代表题

- [LeetCode 455 - 分配饼干](https://leetcode.cn/problems/assign-cookies/)（基础模板）
- [LeetCode 881 - 救生艇](https://leetcode.cn/problems/boats-to-save-people/)（双指针升级版）
- [LeetCode 826 - 安排工作以达到最大收益](https://leetcode.cn/problems/most-profit-assigning-work/)

> 刷完这一类后，几乎所有“分配 / 匹配”问题都可以直接套模板

---

## 2️⃣ 区间调度 / 覆盖型（Interval Greedy）

### 核心问题

> 在区间约束下，选最多 / 删最少 / 覆盖全部

### 统一贪心策略

* 按 **右端点排序**
* 每次选择“结束最早”的区间

### 代表题

- [LeetCode 435 - 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)
- [LeetCode 452 - 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)
- [LeetCode 1024 - 视频拼接](https://leetcode.cn/problems/video-stitching/)

---

## 3️⃣ 排序 + 线性扫描型

### 核心问题

> 决策顺序一旦确定，线性扫描即可完成最优解

### 代表题

- [LeetCode 406 - 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)
- [LeetCode 135 - 分发糖果](https://leetcode.cn/problems/candy/)
- [LeetCode 621 - 任务调度器](https://leetcode.cn/problems/task-scheduler/)

---

## 4️⃣ 堆 + 贪心（动态最优选择）

### 核心问题

> 每一步都要在动态变化的候选集中选最优

### 代表题

- [LeetCode 253 - 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/)
- [LeetCode 502 - IPO](https://leetcode.cn/problems/ipo/)
- [LeetCode 857 - 雇佣 K 名工人的最低成本](https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/)

---

## 5️⃣ 字符串 / 数组构造型（单调结构贪心）

### 核心问题

> 在满足约束下，构造字典序最优的结果

### 代表题

- [LeetCode 402 - 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/)
- [LeetCode 316 - 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)
- [LeetCode 1081 - 去除重复字母 II（Smallest Subsequence）](https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/)

---

## 三、LeetCode 881 救生艇 —— 贪心思想的极简实现

### 题目摘要

* 每个人有体重 `people[i]`
* 每条船最多载 2 人，总重量不超过 `limit`
* 求最少船数

---

### 核心贪心思想

> **最重的人一定要上船**；
> 如果他能和最轻的人同船，这是最优的；
> 否则只能单独一条船。

这是典型的 **资源–需求匹配型贪心**。

---

### 极其优雅的实现

```cpp
int numRescueBoats(vector<int> &people, int limit) {
    sort(people.begin(), people.end());
    int left = 0;
    int right = people.size() - 1;
    int boats = 0;

    while (left <= right) {
        if (people[left] + people[right] <= limit) {
            left++;
        }
        right--;
        boats++;
    }
    return boats;
}
```

---

### 为什么这段代码是“对的”

#### 1️⃣ 为什么一定先考虑最重的人？

* 最重的人是**最难被安置的**
* 如果他现在不被安排，后续只会更难

#### 2️⃣ 为什么优先尝试配最轻的人？

* 最轻的人消耗最少资源
* 如果最轻的人都配不上最重的人，其他人更不可能

#### 3️⃣ 为什么 `right--` 一定执行？

* 每一条船，**至少会带走一个最重的人**
* 所以 `right` 对应的人一定被处理掉

#### 4️⃣ 为什么这是最优的？（交换论证）

* 若最优解中，最重的人与一个比 `left` 更重的人同船
* 用 `left` 替换，只会占用更少重量，不会变差

因此，贪心选择不影响全局最优。

---

## 四、从这道题抽象出的通用模板

```text
1. 排序
2. 最难处理的对象必须优先决策
3. 尝试用最小代价与其匹配
4. 无论成功与否，都能确定一次不可回退的决策
```

---

## 六、总结一句话

> 贪心不是“拍脑袋”，而是**在不可回退的前提下，做出不会后悔的局部最优选择**。

